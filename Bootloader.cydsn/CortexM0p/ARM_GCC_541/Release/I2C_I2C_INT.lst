ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m0plus
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 0
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.syntax unified
  15              		.file	"I2C_I2C_INT.c"
  16              		.text
  17              	.Ltext0:
  18              		.cfi_sections	.debug_frame
  19              		.section	.text.I2C_I2C_ISR,"ax",%progbits
  20              		.align	1
  21              		.global	I2C_I2C_ISR
  22              		.code	16
  23              		.thumb_func
  24              		.type	I2C_I2C_ISR, %function
  25              	I2C_I2C_ISR:
  26              	.LFB1:
  27              		.file 1 "Generated_Source\\PSoC4\\I2C_I2C_INT.c"
   1:Generated_Source\PSoC4/I2C_I2C_INT.c **** /***************************************************************************//**
   2:Generated_Source\PSoC4/I2C_I2C_INT.c **** * \file I2C_I2C_INT.c
   3:Generated_Source\PSoC4/I2C_I2C_INT.c **** * \version 3.20
   4:Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   5:Generated_Source\PSoC4/I2C_I2C_INT.c **** * \brief
   6:Generated_Source\PSoC4/I2C_I2C_INT.c **** *  This file provides the source code to the Interrupt Service Routine for
   7:Generated_Source\PSoC4/I2C_I2C_INT.c **** *  the SCB Component in I2C mode.
   8:Generated_Source\PSoC4/I2C_I2C_INT.c **** *
   9:Generated_Source\PSoC4/I2C_I2C_INT.c **** * Note:
  10:Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  11:Generated_Source\PSoC4/I2C_I2C_INT.c **** ********************************************************************************
  12:Generated_Source\PSoC4/I2C_I2C_INT.c **** * \copyright
  13:Generated_Source\PSoC4/I2C_I2C_INT.c **** * Copyright 2013-2016, Cypress Semiconductor Corporation.  All rights reserved.
  14:Generated_Source\PSoC4/I2C_I2C_INT.c **** * You may use this file only in accordance with the license, terms, conditions,
  15:Generated_Source\PSoC4/I2C_I2C_INT.c **** * disclaimers, and limitations in the end user license agreement accompanying
  16:Generated_Source\PSoC4/I2C_I2C_INT.c **** * the software package with which this file was provided.
  17:Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
  18:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  19:Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_PVT.h"
  20:Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "I2C_I2C_PVT.h"
  21:Generated_Source\PSoC4/I2C_I2C_INT.c **** #include "cyapicallbacks.h"
  22:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  23:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  24:Generated_Source\PSoC4/I2C_I2C_INT.c **** /*******************************************************************************
  25:Generated_Source\PSoC4/I2C_I2C_INT.c **** * Function Name: I2C_I2C_ISR
  26:Generated_Source\PSoC4/I2C_I2C_INT.c **** ****************************************************************************//**
  27:Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  28:Generated_Source\PSoC4/I2C_I2C_INT.c **** *  Handles the Interrupt Service Routine for the SCB I2C mode.
  29:Generated_Source\PSoC4/I2C_I2C_INT.c **** *
  30:Generated_Source\PSoC4/I2C_I2C_INT.c **** *******************************************************************************/
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 2


  31:Generated_Source\PSoC4/I2C_I2C_INT.c **** CY_ISR(I2C_I2C_ISR)
  32:Generated_Source\PSoC4/I2C_I2C_INT.c **** {
  28              		.loc 1 32 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 8
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  32              	.LVL0:
  33:Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 diffCount;
  34:Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 endTransfer;
  35:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  36:Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_ENTRY_CALLBACK
  37:Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_EntryCallback();
  38:Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_ENTRY_CALLBACK */
  39:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  40:Generated_Source\PSoC4/I2C_I2C_INT.c **** #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
  41:Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 response;
  42:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  43:Generated_Source\PSoC4/I2C_I2C_INT.c ****     response = I2C_I2C_ACK_ADDR;
  44:Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
  45:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  46:Generated_Source\PSoC4/I2C_I2C_INT.c ****     endTransfer = 0u; /* Continue active transfer */
  47:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  48:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Calls customer routine if registered */
  49:Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(NULL != I2C_customIntrHandler)
  33              		.loc 1 49 0
  34 0000 BB4B     		ldr	r3, .L77
  32:Generated_Source\PSoC4/I2C_I2C_INT.c ****     uint32 diffCount;
  35              		.loc 1 32 0
  36 0002 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
  37              		.cfi_def_cfa_offset 32
  38              		.cfi_offset 0, -32
  39              		.cfi_offset 1, -28
  40              		.cfi_offset 2, -24
  41              		.cfi_offset 4, -20
  42              		.cfi_offset 5, -16
  43              		.cfi_offset 6, -12
  44              		.cfi_offset 7, -8
  45              		.cfi_offset 14, -4
  46              		.loc 1 49 0
  47 0004 1B68     		ldr	r3, [r3]
  48 0006 002B     		cmp	r3, #0
  49 0008 00D0     		beq	.L2
  50:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  51:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_customIntrHandler();
  50              		.loc 1 51 0
  51 000a 9847     		blx	r3
  52              	.LVL1:
  53              	.L2:
  52:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  53:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  54:Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_INTR_I2C_EC_MASKED(I2C_INTR_I2C_EC_WAKE_UP))
  54              		.loc 1 54 0
  55 000c B94B     		ldr	r3, .L77+4
  56 000e 1B68     		ldr	r3, [r3]
  57 0010 DB07     		lsls	r3, r3, #31
  58 0012 02D5     		bpl	.L3
  55:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 3


  56:Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Mask-off after wakeup */
  57:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetI2CExtClkInterruptMode(I2C_NO_INTR_SOURCES);
  59              		.loc 1 57 0
  60 0014 0022     		movs	r2, #0
  61 0016 B84B     		ldr	r3, .L77+8
  62 0018 1A60     		str	r2, [r3]
  63              	.L3:
  58:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
  59:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  60:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* Master and Slave error tracking:
  61:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Add the master state check to track only the master errors when the master is active or
  62:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * track slave errors when the slave is active or idle.
  63:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * A special MMS case: in the address phase with misplaced Start: the master sets the LOST_ARB a
  64:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * slave BUS_ERR. The valid event is LOST_ARB comes from the master.
  65:Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
  66:Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
  64              		.loc 1 66 0
  65 001a 2020     		movs	r0, #32
  66 001c B74B     		ldr	r3, .L77+12
  67 001e 1A78     		ldrb	r2, [r3]
  68 0020 0242     		tst	r2, r0
  69 0022 19D1     		bne	.L4
  67:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
  68:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
  69:Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
  70:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_BUS_ERROR:
  71:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A misplaced Start or Stop condition occurred on the bus: complete the transaction.
  72:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt is cleared in I2C_FSM_EXIT_IDLE.
  73:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
  74:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_BUS_ERROR))
  75:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  76:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  77:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_BUS_ERROR);
  78:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  79:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  80:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
  81:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  82:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_ARB_LOST:
  83:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The MultiMaster lost arbitrage during transaction.
  84:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition is treated as lost arbitration when the master dr
  85:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The interrupt source is cleared in I2C_FSM_EXIT_IDLE.
  86:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
  87:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
  88:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  89:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
  90:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_I2C_MSTAT_ERR_ARB_LOST);
  91:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  92:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
  93:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
  94:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
  95:Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if(I2C_I2C_MULTI_MASTER_SLAVE)
  96:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
  97:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* I2C_MASTER_CMD_M_START_ON_IDLE:
  98:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * MultiMaster-Slave does not generate start, because Slave was addressed.
  99:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * Pass control to slave.
 100:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 101:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 4


 102:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 103:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 104:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                              I2C_I2C_MSTAT_ERR_ABORT_XFER);
 105:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 106:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 107:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 108:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 109:Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif
 110:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 111:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* The error handling common part:
 112:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Sets a completion flag of the master transaction and passes control to:
 113:Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_EXIT_IDLE - to complete transaction in case of: ARB_LOST or BUS_ERR.
 114:Generated_Source\PSoC4/I2C_I2C_INT.c ****             *  - I2C_FSM_IDLE      - to take chance for the slave to process incoming transaction.
 115:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 116:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(0u != endTransfer)
 117:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 118:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Set completion flags for master */
 119:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 120:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 121:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if(I2C_I2C_MULTI_MASTER_SLAVE)
 122:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 123:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_ADDR)
 124:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 125:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start generation is set after another master starts accessing Slave.
 126:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Clean-up master and turn to slave. Set state to IDLE.
 127:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 128:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_MASTER_CMD(I2C_I2C_MASTER_CMD_M_START_ON_IDLE))
 129:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 130:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_I2C_MASTER_CLEAR_START;
 131:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 132:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 133:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 134:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Valid arbitration lost on the address phase happens only when: master LO
 135:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * slave BUS_ERR is cleared. Only in that case set the state to IDLE without
 136:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 137:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if((!I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR))
 138:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                && I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_ARB_LOST))
 139:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 140:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER; /* Pass control to Slave */
 141:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 142:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 143:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 144:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = 0u; /* Causes I2C_FSM_EXIT_IDLE to be set below */
 145:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 146:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 147:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(0u != endTransfer) /* Clean-up master to proceed with slave */
 148:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 149:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO; /* Shifter keeps address, clear it */
 150:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 151:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_DISABLE_MASTER_AUTO_DATA_ACK; /* In case of reading disable autoACK
 152:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 153:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Clean-up master interrupt sources */
 154:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 155:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 156:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Disable data processing interrupts: they have to be cleared before *
 157:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 158:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 5


 159:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 160:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_IDLE;
 161:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 162:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 163:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 164:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Set I2C_FSM_EXIT_IDLE for BUS_ERR and ARB_LOST (that is really bus e
 165:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 166:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 167:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 168:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 169:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 170:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set I2C_FSM_EXIT_IDLE if any other state than address */
 171:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 172:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 173:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 174:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #else
 175:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 176:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* In case of LOST*/
 177:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 178:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 179:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 180:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 181:Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 182:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 183:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 184:Generated_Source\PSoC4/I2C_I2C_INT.c ****     else /* (I2C_CHECK_I2C_FSM_SLAVE) */
 185:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 186:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 187:Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 188:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_BUS_ERROR or I2C_INTR_SLAVE_I2C_ARB_LOST:
 189:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Misplaced Start or Stop condition occurred on the bus: set a flag
 190:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * to notify an error condition.
 191:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 192:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_BUS_ERROR |
  70              		.loc 1 192 0
  71 0024 B64A     		ldr	r2, .L77+16
  72 0026 1168     		ldr	r1, [r2]
  73 0028 0222     		movs	r2, #2
  74 002a FF32     		adds	r2, r2, #255
  75 002c 1142     		tst	r1, r2
  76 002e 13D0     		beq	.L4
 193:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                         I2C_INTR_SLAVE_I2C_ARB_LOST))
 194:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 195:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_RD)
  77              		.loc 1 195 0
  78 0030 1978     		ldrb	r1, [r3]
  79 0032 B44A     		ldr	r2, .L77+20
  80 0034 C907     		lsls	r1, r1, #31
  81 0036 06D5     		bpl	.L5
 196:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 197:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 198:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
  82              		.loc 1 198 0
  83 0038 1178     		ldrb	r1, [r2]
  84 003a 1E38     		subs	r0, r0, #30
  85 003c 8143     		bics	r1, r0
  86 003e 1170     		strb	r1, [r2]
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 6


 199:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_RD_ERR |
  87              		.loc 1 199 0
  88 0040 1178     		ldrb	r1, [r2]
  89 0042 0730     		adds	r0, r0, #7
  90 0044 04E0     		b	.L69
  91              	.L5:
 200:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_RD_CMPLT);
 201:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 202:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 203:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 204:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 205:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
  92              		.loc 1 205 0
  93 0046 1178     		ldrb	r1, [r2]
  94 0048 8143     		bics	r1, r0
  95 004a 1170     		strb	r1, [r2]
 206:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) (I2C_I2C_SSTAT_WR_ERR |
  96              		.loc 1 206 0
  97 004c 9021     		movs	r1, #144
  98 004e 1078     		ldrb	r0, [r2]
  99              	.L69:
 100 0050 0143     		orrs	r1, r0
 101 0052 1170     		strb	r1, [r2]
 207:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                           I2C_I2C_SSTAT_WR_CMPLT);
 208:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 209:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 210:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state = I2C_I2C_FSM_EXIT_IDLE;
 102              		.loc 1 210 0
 103 0054 0022     		movs	r2, #0
 104 0056 1A70     		strb	r2, [r3]
 105              	.L4:
 211:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 212:Generated_Source\PSoC4/I2C_I2C_INT.c ****         }
 213:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 214:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 215:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 216:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* States description:
 217:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Master operation starts from: the ADDR_RD/WR state as the master generates traffic on the
 218:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Any Slave operation starts from: the IDLE state as the slave always waits for actions from th
 219:Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 220:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 221:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Master */
 222:Generated_Source\PSoC4/I2C_I2C_INT.c ****     if(I2C_CHECK_I2C_FSM_MASTER)
 106              		.loc 1 222 0
 107 0058 1A78     		ldrb	r2, [r3]
 108 005a 9206     		lsls	r2, r2, #26
 109 005c 00D5     		bpl	.LCB94
 110 005e 46E1     		b	.L1	@long jump
 111              	.LCB94:
 223:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 224:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_MASTER)
 225:Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 226:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_MASTER_I2C_STOP:
 227:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * A Stop condition was generated by the master: the end of the transaction.
 228:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Set completion flags to notify the API.
 229:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 230:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_STOP))
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 7


 231:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 232:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_STOP);
 233:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 234:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_mstrStatus |= (uint16) I2C_GET_I2C_MSTAT_CMPLT;
 235:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state       = I2C_I2C_FSM_IDLE;
 236:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 237:Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 238:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 239:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_ADDR) /* Address stage */
 240:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 241:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_MASTER_I2C_NACK:
 242:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * The master sent an address but it was NACKed by the slave. Complete transacti
 243:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 244:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 245:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 246:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 247:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 248:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 249:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_I2C_MSTAT_ERR_ADDR_NAK);
 250:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 251:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 252:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 253:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_TX_UNDERFLOW. The master sent an address:
 254:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - TX direction: the clock is stretched after the ACK phase, because the TX F
 255:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    EMPTY. The TX EMPTY cleans all the TX interrupt sources.
 256:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *  - RX direction: the 1st byte is received, but there is no ACK permission,
 257:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     *    the clock is stretched after 1 byte is received.
 258:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 259:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 260:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 261:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 262:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 263:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_RD_DATA;
 264:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 265:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else /* Writing */
 266:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 267:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_state = I2C_I2C_FSM_MSTR_WR_DATA;
 268:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(0u != I2C_mstrWrBufSize)
 269:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 270:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Enable INTR.TX_EMPTY if there is data to transmit */
 271:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 272:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 273:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 274:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 275:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 276:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 277:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_I2C_FSM_DATA) /* Data phase */
 278:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 279:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_FSM_RD) /* Reading */
 280:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 281:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_FULL:
 282:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received 8 bytes.
 283:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Get data from RX FIFO and decide whether to ACK or  NACK the following by
 284:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 285:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
 286:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 287:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Calculate difference */
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 8


 288:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             diffCount =  I2C_mstrRdBufSize -
 289:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         (I2C_mstrRdBufIndex + I2C_GET_RX_FIFO_ENTRIES);
 290:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 291:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Proceed transaction or end it when RX FIFO becomes FULL again */
 292:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount > I2C_I2C_FIFO_SIZE)
 293:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 294:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 diffCount = I2C_I2C_FIFO_SIZE;
 295:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 296:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 297:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 298:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(0u == diffCount)
 299:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 300:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 301:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 302:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     diffCount   = I2C_I2C_FIFO_SIZE;
 303:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 304:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 305:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 306:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 307:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             for(; (0u != diffCount); diffCount--)
 308:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 309:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8)
 310:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                                         I2C_RX_FIFO
 311:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_mstrRdBufIndex++;
 312:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 313:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 314:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_RX_NOT_EMPTY:
 315:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * RX direction: the master received one data byte, ACK or NACK it.
 316:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The last byte is stored and NACKed by the master. The NACK and Stop is
 317:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * generated by one command generate Stop.
 318:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 319:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 320:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 321:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Put data in component buffer */
 322:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufPtr[I2C_mstrRdBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 323:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrRdBufIndex++;
 324:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 325:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrRdBufIndex < I2C_mstrRdBufSize)
 326:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 327:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_I2C_MASTER_GENERATE_ACK;
 328:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 329:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 330:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 331:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 332:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 333:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 334:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 335:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 336:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 337:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 338:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 339:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 340:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 341:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else /* Writing */
 342:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 343:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_MASTER_I2C_NACK :
 344:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The master writes data to the slave and NACK was received: not all the by
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 9


 345:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * written to the slave from the TX FIFO. Revert the index if there is data 
 346:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the TX FIFO and pass control to a complete transfer.
 347:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 348:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_CHECK_INTR_MASTER_MASKED(I2C_INTR_MASTER_I2C_NACK))
 349:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 350:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_I2C_NACK);
 351:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 352:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Rollback write buffer index: NACKed byte remains in shifter */
 353:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndexTmp -= (I2C_GET_TX_FIFO_ENTRIES +
 354:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                    I2C_GET_TX_FIFO_SR_VALID);
 355:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 356:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 357:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 358:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 359:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_ERR_XFER |
 360:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                      I2C_I2C_MSTAT_ERR_SHORT_XFER);
 361:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 362:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_CLEAR_TX_FIFO;
 363:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 364:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 365:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 366:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_EMPTY :
 367:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: the TX FIFO is EMPTY, the data from the buffer needs to be 
 368:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * When there is no data in the component buffer, the underflow interrupt is
 369:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * enabled to catch when all the data has been transferred.
 370:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 371:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
 372:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 373:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 374:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 375:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* The temporary mstrWrBufIndexTmp is used because slave could NACK
 376:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 * roll-back required in this case. The mstrWrBufIndex is updated at
 377:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 */
 378:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(I2C_mstrWrBufIndexTmp < I2C_mstrWrBufSize)
 379:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 380:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 #if(!I2C_CY_SCBIP_V0)
 381:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                    /* Clear INTR_TX.UNDERFLOW before putting the last byte into TX 
 382:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * a proper trigger at the end of transaction when INTR_TX.UNDER
 383:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     * event. Ticket ID# 156735.
 384:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     */
 385:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     if(I2C_mstrWrBufIndexTmp == (I2C_mstrWrBufSize - 1u))
 386:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     {
 387:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_ClearTxInterruptSource(I2C_INTR_TX_UNDERFLOW);
 388:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                         I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 389:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     }
 390:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                  #endif /* (!I2C_CY_SCBIP_V0) */
 391:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 392:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Put data into TX FIFO */
 393:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_TX_FIFO_WR_REG = (uint32) I2C_mstrWrBufPtr[I2C_mstrWrBufInd
 394:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_mstrWrBufIndexTmp++;
 395:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 396:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 397:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 398:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     break; /* No more data to put */
 399:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 400:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 401:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 10


 402:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CY_SCBIP_V0)
 403:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(I2C_mstrWrBufIndexTmp == I2C_mstrWrBufSize)
 404:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 405:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetTxInterruptMode(I2C_INTR_TX_UNDERFLOW);
 406:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 407:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 408:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_ALL);
 409:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 410:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 411:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif /* (I2C_CY_SCBIP_V0) */
 412:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 413:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* INTR_TX_UNDERFLOW:
 414:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * TX direction: all data from the TX FIFO was transferred to the slave.
 415:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The transaction needs to be completed.
 416:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 417:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_UNDERFLOW))
 418:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 419:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Update number of transferred bytes */
 420:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_mstrWrBufIndex = I2C_mstrWrBufIndexTmp;
 421:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 422:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 423:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 424:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 425:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 426:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Do nothing */
 427:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 428:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 429:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 430:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 431:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* Complete transfer */
 432:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 433:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clean-up master after reading: only in case of NACK */
 434:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_MASTER_AUTO_DATA_ACK;
 435:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 436:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable data processing interrupts: they have to be cleared before */
 437:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 438:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 439:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 440:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_MODE_NO_STOP(I2C_mstrControl))
 441:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 442:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* On-going transaction is suspended: the ReStart is generated by the API r
 443:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_mstrStatus |= (uint16) (I2C_I2C_MSTAT_XFER_HALT |
 444:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                                  I2C_GET_I2C_MSTAT_CMPLT);
 445:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 446:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state = I2C_I2C_FSM_MSTR_HALT;
 447:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 448:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 449:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 450:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Complete transaction: exclude the data processing state and generate Sto
 451:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * The completion status will be set after Stop generation.
 452:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * A special case is read: because NACK and Stop are generated by the comman
 453:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * Lost arbitration can occur during NACK generation when
 454:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * the other master is still reading from the slave.
 455:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         */
 456:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_I2C_MASTER_GENERATE_STOP;
 457:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 458:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 11


 459:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 460:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 461:Generated_Source\PSoC4/I2C_I2C_INT.c ****         } /* (I2C_I2C_MASTER) */
 462:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 463:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 464:Generated_Source\PSoC4/I2C_I2C_INT.c ****     } /* (I2C_CHECK_I2C_FSM_MASTER) */
 465:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 466:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 467:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM Slave */
 468:Generated_Source\PSoC4/I2C_I2C_INT.c ****     else if(I2C_CHECK_I2C_FSM_SLAVE)
 112              		.loc 1 468 0
 113 0060 1020     		movs	r0, #16
 114 0062 1A78     		ldrb	r2, [r3]
 115 0064 0242     		tst	r2, r0
 116 0066 00D1     		bne	.LCB101
 117 0068 2DE1     		b	.L9	@long jump
 118              	.LCB101:
 469:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 470:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if(I2C_I2C_SLAVE)
 471:Generated_Source\PSoC4/I2C_I2C_INT.c ****         {
 472:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_NACK:
 473:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes reading the slave: the appropriate flags have to be set.
 474:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The TX FIFO is cleared after an overflow condition is set.
 475:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 476:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_NACK))
 119              		.loc 1 476 0
 120 006a 0222     		movs	r2, #2
 121 006c A448     		ldr	r0, .L77+16
 122 006e 0168     		ldr	r1, [r0]
 123 0070 1142     		tst	r1, r2
 124 0072 34D0     		beq	.L10
 477:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 478:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_NACK);
 125              		.loc 1 478 0
 126 0074 A449     		ldr	r1, .L77+24
 127 0076 A54D     		ldr	r5, .L77+28
 128 0078 0A60     		str	r2, [r1]
 479:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 480:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* All entries that remain in TX FIFO are: FIFO Size + 1 (SHIFTER) */
 481:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = (I2C_GET_TX_FIFO_ENTRIES + I2C_GET_TX_FIFO_SR_VALID);
 129              		.loc 1 481 0
 130 007a A549     		ldr	r1, .L77+32
 131 007c 1D32     		adds	r2, r2, #29
 132 007e 0C68     		ldr	r4, [r1]
 133 0080 0968     		ldr	r1, [r1]
 134 0082 2240     		ands	r2, r4
 482:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 483:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slOverFlowCount > diffCount) /* Overflow */
 135              		.loc 1 483 0
 136 0084 A34C     		ldr	r4, .L77+36
 481:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 137              		.loc 1 481 0
 138 0086 0904     		lsls	r1, r1, #16
 139 0088 C90F     		lsrs	r1, r1, #31
 140              		.loc 1 483 0
 141 008a 2678     		ldrb	r6, [r4]
 481:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 12


 142              		.loc 1 481 0
 143 008c 8A18     		adds	r2, r1, r2
 144              	.LVL2:
 145 008e 9D49     		ldr	r1, .L77+20
 146              		.loc 1 483 0
 147 0090 B242     		cmp	r2, r6
 148 0092 04D2     		bcs	.L11
 484:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 485:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_OVFL;
 149              		.loc 1 485 0
 150 0094 0426     		movs	r6, #4
 151 0096 0A78     		ldrb	r2, [r1]
 152              	.LVL3:
 153 0098 3243     		orrs	r2, r6
 154 009a 0A70     		strb	r2, [r1]
 155 009c 04E0     		b	.L12
 156              	.LVL4:
 157              	.L11:
 486:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 487:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* No Overflow */
 488:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 489:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Roll-back temporary index */
 490:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slRdBufIndexTmp -= (diffCount - I2C_slOverFlowCount);
 158              		.loc 1 490 0
 159 009e 2778     		ldrb	r7, [r4]
 160 00a0 2E68     		ldr	r6, [r5]
 161 00a2 D21B     		subs	r2, r2, r7
 162              	.LVL5:
 163 00a4 B21A     		subs	r2, r6, r2
 164 00a6 2A60     		str	r2, [r5]
 165              	.L12:
 491:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 492:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 493:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Update slave of transferred bytes */
 494:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slRdBufIndex = I2C_slRdBufIndexTmp;
 166              		.loc 1 494 0
 167 00a8 2D68     		ldr	r5, [r5]
 168 00aa 9B4A     		ldr	r2, .L77+40
 169 00ac 1560     		str	r5, [r2]
 495:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 496:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clean-up TX FIFO */
 497:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 170              		.loc 1 497 0
 171 00ae 0022     		movs	r2, #0
 172 00b0 9A4D     		ldr	r5, .L77+44
 173 00b2 2A60     		str	r2, [r5]
 498:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slOverFlowCount = 0u;
 499:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_CLEAR_TX_FIFO;
 174              		.loc 1 499 0
 175 00b4 8025     		movs	r5, #128
 498:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slOverFlowCount = 0u;
 176              		.loc 1 498 0
 177 00b6 2270     		strb	r2, [r4]
 178              		.loc 1 499 0
 179 00b8 994C     		ldr	r4, .L77+48
 180 00ba 6D02     		lsls	r5, r5, #9
 181 00bc 2268     		ldr	r2, [r4]
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 13


 182 00be 2A43     		orrs	r2, r5
 183 00c0 2260     		str	r2, [r4]
 184 00c2 2568     		ldr	r5, [r4]
 185 00c4 974A     		ldr	r2, .L77+52
 186 00c6 2A40     		ands	r2, r5
 187 00c8 2260     		str	r2, [r4]
 500:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 501:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master reading */
 502:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_RD_BUSY;
 188              		.loc 1 502 0
 189 00ca 0224     		movs	r4, #2
 190 00cc 0A78     		ldrb	r2, [r1]
 191 00ce A243     		bics	r2, r4
 192 00d0 0A70     		strb	r2, [r1]
 503:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_RD_CMPLT;
 193              		.loc 1 503 0
 194 00d2 0A78     		ldrb	r2, [r1]
 195 00d4 013C     		subs	r4, r4, #1
 196 00d6 2243     		orrs	r2, r4
 197 00d8 0A70     		strb	r2, [r1]
 504:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 198              		.loc 1 504 0
 199 00da 1022     		movs	r2, #16
 200 00dc 1A70     		strb	r2, [r3]
 201              	.L10:
 505:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 506:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 507:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 508:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_WRITE_STOP:
 509:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master completes writing to the slave: the appropriate flags have to be set.
 510:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The RX FIFO contains 1-8 bytes from the previous transaction which needs to be read.
 511:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility that RX FIFO contains an address, it needs to leave it there.
 512:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 513:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_WRITE_STOP))
 202              		.loc 1 513 0
 203 00de 0822     		movs	r2, #8
 204 00e0 0168     		ldr	r1, [r0]
 205 00e2 1142     		tst	r1, r2
 206 00e4 35D0     		beq	.L13
 514:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 515:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 207              		.loc 1 515 0
 208 00e6 8849     		ldr	r1, .L77+24
 209 00e8 0A60     		str	r2, [r1]
 516:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 517:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Read bytes from RX FIFO when auto data ACK receive logic is enabled. Otherwise a
 518:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * were already read from the RX FIFO except for address byte which has to stay here
 519:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 * I2C_ADDR_MATCH.
 520:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 */
 521:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (0u != (I2C_I2C_CTRL_REG & I2C_I2C_CTRL_S_READY_DATA_ACK))
 210              		.loc 1 521 0
 211 00ea 8F4A     		ldr	r2, .L77+56
 212 00ec 1168     		ldr	r1, [r2]
 213 00ee 8904     		lsls	r1, r1, #18
 214 00f0 17D5     		bpl	.L15
 522:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 523:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     while(0u != I2C_GET_RX_FIFO_ENTRIES)
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 14


 524:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 525:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 526:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 527:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if((1u == I2C_GET_RX_FIFO_ENTRIES) &&
 528:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH)))
 529:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 530:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 break; /* Leave address in RX FIFO */
 531:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 532:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 533:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 534:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 535:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Put data in component buffer */
 536:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 215              		.loc 1 536 0
 216 00f2 8E49     		ldr	r1, .L77+60
 217 00f4 8E4F     		ldr	r7, .L77+64
 218              	.L68:
 523:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 219              		.loc 1 523 0
 220 00f6 1F25     		movs	r5, #31
 221 00f8 8E4C     		ldr	r4, .L77+68
 222 00fa 2468     		ldr	r4, [r4]
 223 00fc 2C42     		tst	r4, r5
 224 00fe 0CD0     		beq	.L74
 225              		.loc 1 536 0
 226 0100 6E46     		mov	r6, sp
 227 0102 0C68     		ldr	r4, [r1]
 228 0104 3D68     		ldr	r5, [r7]
 229 0106 2C19     		adds	r4, r5, r4
 230 0108 8B4D     		ldr	r5, .L77+72
 231 010a 2D68     		ldr	r5, [r5]
 232 010c F571     		strb	r5, [r6, #7]
 233 010e F579     		ldrb	r5, [r6, #7]
 234 0110 2570     		strb	r5, [r4]
 537:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slWrBufIndex++;
 235              		.loc 1 537 0
 236 0112 0C68     		ldr	r4, [r1]
 237 0114 0134     		adds	r4, r4, #1
 238 0116 0C60     		str	r4, [r1]
 239 0118 EDE7     		b	.L68
 240              	.L74:
 538:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 539:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 540:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_SLAVE_AUTO_DATA;
 241              		.loc 1 540 0
 242 011a 1468     		ldr	r4, [r2]
 243 011c 8749     		ldr	r1, .L77+76
 244 011e 2140     		ands	r1, r4
 245 0120 1160     		str	r1, [r2]
 246              	.L15:
 541:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 542:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 543:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_CHECK_INTR_RX(I2C_INTR_RX_OVERFLOW))
 247              		.loc 1 543 0
 248 0122 874A     		ldr	r2, .L77+80
 249 0124 7749     		ldr	r1, .L77+20
 250 0126 1568     		ldr	r5, [r2]
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 15


 251 0128 1400     		movs	r4, r2
 252 012a AA06     		lsls	r2, r5, #26
 253 012c 03D5     		bpl	.L17
 544:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 545:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 254              		.loc 1 545 0
 255 012e 4025     		movs	r5, #64
 256 0130 0A78     		ldrb	r2, [r1]
 257 0132 2A43     		orrs	r2, r5
 258 0134 0A70     		strb	r2, [r1]
 259              	.L17:
 546:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 547:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 548:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clears RX interrupt sources triggered on data receiving */
 549:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 260              		.loc 1 549 0
 261 0136 0025     		movs	r5, #0
 262 0138 824A     		ldr	r2, .L77+84
 263 013a 1560     		str	r5, [r2]
 550:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 264              		.loc 1 550 0
 265 013c 824A     		ldr	r2, .L77+88
 266 013e 2260     		str	r2, [r4]
 551:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 552:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Complete master writing */
 553:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus &= (uint8) ~I2C_I2C_SSTAT_WR_BUSY;
 267              		.loc 1 553 0
 268 0140 2024     		movs	r4, #32
 269 0142 0A78     		ldrb	r2, [r1]
 270 0144 A243     		bics	r2, r4
 271 0146 0A70     		strb	r2, [r1]
 554:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_slStatus |= (uint8)  I2C_I2C_SSTAT_WR_CMPLT;
 272              		.loc 1 554 0
 273 0148 0A78     		ldrb	r2, [r1]
 274 014a 103C     		subs	r4, r4, #16
 275 014c 2243     		orrs	r2, r4
 276 014e 0A70     		strb	r2, [r1]
 555:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_state     =  I2C_I2C_FSM_IDLE;
 277              		.loc 1 555 0
 278 0150 1C70     		strb	r4, [r3]
 279              	.L13:
 556:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 557:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 558:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 559:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* INTR_SLAVE_I2C_ADDR_MATCH or INTR_SLAVE_I2C_GENERAL:
 560:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The address match or general call address event starts the slave operation:
 561:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * after leaving the TX or RX direction has to be chosen.
 562:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The wakeup interrupt must be cleared only after an address match is set.
 563:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 564:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 565:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH |
 566:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                                          I2C_INTR_SLAVE_I2C_GENERAL))
 567:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #else
 568:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if (I2C_CHECK_INTR_SLAVE_MASKED(I2C_INTR_SLAVE_I2C_ADDR_MATCH))
 280              		.loc 1 568 0
 281 0152 0268     		ldr	r2, [r0]
 282 0154 5206     		lsls	r2, r2, #25
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 16


 283 0156 3ED5     		bpl	.L18
 569:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 570:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 571:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Clear externally clocked address match interrupt source when internally clocked 
 572:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearI2CExtClkInterruptSource(I2C_INTR_I2C_EC_WAKE_UP);
 284              		.loc 1 572 0
 285 0158 0121     		movs	r1, #1
 286 015a 7C4A     		ldr	r2, .L77+92
 287 015c 1160     		str	r1, [r2]
 573:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 574:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER)
 575:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 576:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if (NULL != I2C_customAddressHandler)
 577:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 578:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Call custom address handler */
 579:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_customAddressHandler();
 580:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 581:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 582:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 583:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Read address from the RX FIFO. If there is no address underflow triggers
 584:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         * component does not use that source. */
 585:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         (void) I2C_RX_FIFO_RD_REG;
 586:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         response = I2C_I2C_ACK_ADDR;
 587:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 588:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 589:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clears RX sources after address was received in the RX FIFO */
 590:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearRxInterruptSource(I2C_INTR_RX_ALL);
 591:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 592:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif
 593:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 594:Generated_Source\PSoC4/I2C_I2C_INT.c ****             #if (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST)
 595:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if (response == I2C_I2C_NAK_ADDR)
 596:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 597:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 598:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Disable write stop interrupt source as it triggers after address was NACKed.
 599:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_DISABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 600:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
 601:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 602:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 603:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 604:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 605:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 606:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
 607:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 608:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else
 609:Generated_Source\PSoC4/I2C_I2C_INT.c ****             #endif /* (I2C_I2C_CUSTOM_ADDRESS_HANDLER_CONST) */
 610:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 611:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_CHECK_I2C_STATUS(I2C_I2C_STATUS_S_READ))
 288              		.loc 1 611 0
 289 015e 7C4A     		ldr	r2, .L77+96
 290 0160 6849     		ldr	r1, .L77+20
 291 0162 1068     		ldr	r0, [r2]
 292 0164 1022     		movs	r2, #16
 293 0166 1042     		tst	r0, r2
 294 0168 0BD0     		beq	.L19
 612:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* TX direction: master reads from slave */
 613:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 17


 614:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_SetTxInterruptMode(I2C_INTR_TX_EMPTY);
 295              		.loc 1 614 0
 296 016a 6C48     		ldr	r0, .L77+44
 297 016c 0260     		str	r2, [r0]
 615:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 616:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Set temporary index to address buffer clear from API */
 617:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp = I2C_slRdBufIndex;
 298              		.loc 1 617 0
 299 016e 6A4A     		ldr	r2, .L77+40
 300 0170 1068     		ldr	r0, [r2]
 301 0172 664A     		ldr	r2, .L77+28
 302 0174 1060     		str	r0, [r2]
 618:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 619:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 620:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_RD_BUSY;
 303              		.loc 1 620 0
 304 0176 0220     		movs	r0, #2
 305 0178 0A78     		ldrb	r2, [r1]
 306 017a 0243     		orrs	r2, r0
 307 017c 0A70     		strb	r2, [r1]
 621:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_RD;
 308              		.loc 1 621 0
 309 017e 1222     		movs	r2, #18
 310 0180 1DE0     		b	.L71
 311              	.L19:
 622:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 623:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 624:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* RX direction: master writes into slave */
 625:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 626:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Calculate available buffer size */
 627:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         diffCount = (I2C_slWrBufSize - I2C_slWrBufIndex);
 312              		.loc 1 627 0
 313 0182 744A     		ldr	r2, .L77+100
 314 0184 6948     		ldr	r0, .L77+60
 315 0186 1268     		ldr	r2, [r2]
 316 0188 0068     		ldr	r0, [r0]
 317 018a 121A     		subs	r2, r2, r0
 318              	.LVL6:
 628:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 629:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #if (I2C_CY_SCBIP_V0)
 630:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(diffCount < I2C_I2C_FIFO_SIZE)
 631:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: byte-by-byte */
 632:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 633:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 634:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 635:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         else
 636:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Receive data: into RX FIFO */
 637:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 638:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount == I2C_I2C_FIFO_SIZE)
 639:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 640:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* NACK when RX FIFO become FULL */
 641:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA;
 642:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 643:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 644:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 645:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 /* Stretch clock when RX FIFO becomes FULL */
 646:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 18


 647:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 648:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 649:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 650:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 651:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #else
 652:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #if(I2C_CHECK_I2C_ACCEPT_ADDRESS)
 653:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 654:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Enable RX.NOT_EMPTY interrupt source to receive byte by byte.
 655:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * The byte by byte receive is always chosen for the case when an addres
 656:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             * in RX FIFO. Ticket ID#175559.
 657:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             */
 658:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 659:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 660:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #else
 661:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 662:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             if(diffCount < I2C_I2C_FIFO_SIZE)
 663:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: byte-by-byte */
 664:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 665:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 I2C_SetRxInterruptMode(I2C_INTR_RX_NOT_EMPTY);
 319              		.loc 1 665 0
 320 018c 0420     		movs	r0, #4
 662:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: byte-by-byte */
 321              		.loc 1 662 0
 322 018e 072A     		cmp	r2, #7
 323 0190 0ED9     		bls	.L70
 324 0192 6548     		ldr	r0, .L77+56
 666:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 667:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             else
 668:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Receive data: into RX FIFO */
 669:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             {
 670:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 if(diffCount == I2C_I2C_FIFO_SIZE)
 325              		.loc 1 670 0
 326 0194 082A     		cmp	r2, #8
 327 0196 05D1     		bne	.L23
 671:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 672:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* NACK when RX FIFO become FULL */
 673:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA;
 328              		.loc 1 673 0
 329 0198 A024     		movs	r4, #160
 330 019a 0268     		ldr	r2, [r0]
 331              	.LVL7:
 332 019c 2402     		lsls	r4, r4, #8
 333 019e 2243     		orrs	r2, r4
 334 01a0 0260     		str	r2, [r0]
 335 01a2 07E0     		b	.L22
 336              	.LVL8:
 337              	.L23:
 674:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 675:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 else
 676:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 {
 677:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     /* Stretch clock when RX FIFO becomes FULL */
 678:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_ENABLE_SLAVE_AUTO_DATA_ACK;
 338              		.loc 1 678 0
 339 01a4 8024     		movs	r4, #128
 340 01a6 0268     		ldr	r2, [r0]
 341              	.LVL9:
 342 01a8 A401     		lsls	r4, r4, #6
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 19


 343 01aa 2243     		orrs	r2, r4
 344 01ac 0260     		str	r2, [r0]
 679:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                     I2C_SetRxInterruptMode(I2C_INTR_RX_FULL);
 345              		.loc 1 679 0
 346 01ae 0820     		movs	r0, #8
 347              	.L70:
 348 01b0 644A     		ldr	r2, .L77+84
 349 01b2 1060     		str	r0, [r2]
 350              	.L22:
 680:Generated_Source\PSoC4/I2C_I2C_INT.c ****                                 }
 681:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             }
 682:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 683:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         #endif
 684:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     #endif /* (I2C_CY_SCBIP_V0) */
 685:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 686:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         /* Start master reading */
 687:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_BUSY;
 351              		.loc 1 687 0
 352 01b4 2020     		movs	r0, #32
 353 01b6 0A78     		ldrb	r2, [r1]
 354 01b8 0243     		orrs	r2, r0
 355 01ba 0A70     		strb	r2, [r1]
 688:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_WR;
 356              		.loc 1 688 0
 357 01bc 1122     		movs	r2, #17
 358              	.L71:
 689:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 690:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 691:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Clear address match and stop history */
 692:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 693:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 694:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #if (!I2C_CY_SCBIP_V0)
 695:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Enable write stop interrupt source as it triggers after address was NACKed. 
 696:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_INTR_SLAVE(I2C_INTR_SLAVE_I2C_WRITE_STOP);
 359              		.loc 1 696 0
 360 01be 0821     		movs	r1, #8
 688:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_state     = I2C_I2C_FSM_SL_WR;
 361              		.loc 1 688 0
 362 01c0 1A70     		strb	r2, [r3]
 692:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 363              		.loc 1 692 0
 364 01c2 654A     		ldr	r2, .L77+104
 365 01c4 504B     		ldr	r3, .L77+24
 366 01c6 1A60     		str	r2, [r3]
 367              		.loc 1 696 0
 368 01c8 644A     		ldr	r2, .L77+108
 369 01ca 1368     		ldr	r3, [r2]
 370 01cc 0B43     		orrs	r3, r1
 371 01ce 1360     		str	r3, [r2]
 697:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 #endif /* (!I2C_CY_SCBIP_V0) */
 698:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 699:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* ACK the address byte */
 700:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 372              		.loc 1 700 0
 373 01d0 0122     		movs	r2, #1
 374 01d2 634B     		ldr	r3, .L77+112
 375 01d4 1A60     		str	r2, [r3]
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 20


 376              	.L18:
 701:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 702:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 703:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 704:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_FULL:
 705:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * Get data from the RX FIFO and decide whether to ACK or NACK the following bytes
 706:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 707:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_FULL))
 377              		.loc 1 707 0
 378 01d6 0821     		movs	r1, #8
 379 01d8 624B     		ldr	r3, .L77+116
 380 01da 1A68     		ldr	r2, [r3]
 381 01dc 0A42     		tst	r2, r1
 382 01de 25D0     		beq	.L24
 708:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 709:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Calculate available buffer size to take into account that RX FIFO is FULL */
 710:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount =  I2C_slWrBufSize -
 383              		.loc 1 710 0
 384 01e0 5C4B     		ldr	r3, .L77+100
 385 01e2 524A     		ldr	r2, .L77+60
 386 01e4 1B68     		ldr	r3, [r3]
 387 01e6 1068     		ldr	r0, [r2]
 388 01e8 083B     		subs	r3, r3, #8
 389 01ea 1B1A     		subs	r3, r3, r0
 390              	.LVL10:
 711:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             (I2C_slWrBufIndex + I2C_I2C_FIFO_SIZE);
 712:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 713:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(diffCount > I2C_I2C_FIFO_SIZE) /* Proceed transaction */
 714:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 715:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     diffCount   = I2C_I2C_FIFO_SIZE;
 716:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 717:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 718:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* End when FIFO becomes FULL again */
 719:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 720:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = I2C_I2C_CMPLT_ANY_TRANSFER;
 391              		.loc 1 720 0
 392 01ec 0120     		movs	r0, #1
 713:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 393              		.loc 1 713 0
 394 01ee 8B42     		cmp	r3, r1
 395 01f0 01D9     		bls	.L25
 716:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 396              		.loc 1 716 0
 397 01f2 0020     		movs	r0, #0
 715:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     endTransfer = 0u;  /* Continue active transfer */
 398              		.loc 1 715 0
 399 01f4 0B00     		movs	r3, r1
 400              	.LVL11:
 401              	.L25:
 721:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 722:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 723:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 for(; (0u != diffCount); diffCount--)
 724:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 725:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data in component buffer */
 726:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) I2C_RX_FIFO_RD_REG;
 402              		.loc 1 726 0 discriminator 1
 403 01f6 4E4C     		ldr	r4, .L77+64
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 21


 404 01f8 4F4D     		ldr	r5, .L77+72
 405              	.LVL12:
 406              	.L26:
 723:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 407              		.loc 1 723 0 discriminator 1
 408 01fa 002B     		cmp	r3, #0
 409 01fc 0AD0     		beq	.L75
 410              		.loc 1 726 0 discriminator 2
 411 01fe 1168     		ldr	r1, [r2]
 412 0200 2668     		ldr	r6, [r4]
 723:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 413              		.loc 1 723 0 discriminator 2
 414 0202 013B     		subs	r3, r3, #1
 415              	.LVL13:
 416              		.loc 1 726 0 discriminator 2
 417 0204 7118     		adds	r1, r6, r1
 418 0206 2E68     		ldr	r6, [r5]
 419 0208 F6B2     		uxtb	r6, r6
 420 020a 0E70     		strb	r6, [r1]
 727:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 421              		.loc 1 727 0 discriminator 2
 422 020c 1168     		ldr	r1, [r2]
 423 020e 0131     		adds	r1, r1, #1
 424 0210 1160     		str	r1, [r2]
 425 0212 F2E7     		b	.L26
 426              	.L75:
 728:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 729:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 730:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(0u != endTransfer) /* End transfer sending NACK */
 427              		.loc 1 730 0
 428 0214 0028     		cmp	r0, #0
 429 0216 07D0     		beq	.L28
 731:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 732:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_ENABLE_SLAVE_AUTO_DATA_NACK;
 430              		.loc 1 732 0
 431 0218 8020     		movs	r0, #128
 432              	.LVL14:
 433 021a 4349     		ldr	r1, .L77+56
 434 021c 0002     		lsls	r0, r0, #8
 435 021e 0A68     		ldr	r2, [r1]
 436 0220 0243     		orrs	r2, r0
 437 0222 0A60     		str	r2, [r1]
 733:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 734:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* INTR_RX_FULL triggers earlier than INTR_SLAVE_I2C_STOP:
 735:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * disable all RX interrupt sources.
 736:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 737:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 438              		.loc 1 737 0
 439 0224 474A     		ldr	r2, .L77+84
 440 0226 1360     		str	r3, [r2]
 441              	.L28:
 738:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 739:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 740:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_FULL);
 442              		.loc 1 740 0
 443 0228 0822     		movs	r2, #8
 444 022a 1FE0     		b	.L72
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 22


 445              	.LVL15:
 446              	.L24:
 741:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 742:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_RX_NOT_EMPTY:
 743:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The buffer size is less than 8: it requires processing in byte-by-byte mode.
 744:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 745:Generated_Source\PSoC4/I2C_I2C_INT.c ****             else if(I2C_CHECK_INTR_RX_MASKED(I2C_INTR_RX_NOT_EMPTY))
 447              		.loc 1 745 0
 448 022c 1B68     		ldr	r3, [r3]
 449 022e 5B07     		lsls	r3, r3, #29
 450 0230 1ED5     		bpl	.L29
 746:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 747:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 diffCount = I2C_RX_FIFO_RD_REG;
 451              		.loc 1 747 0
 452 0232 414B     		ldr	r3, .L77+72
 748:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 749:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 if(I2C_slWrBufIndex < I2C_slWrBufSize)
 453              		.loc 1 749 0
 454 0234 3D49     		ldr	r1, .L77+60
 747:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 455              		.loc 1 747 0
 456 0236 1A68     		ldr	r2, [r3]
 457              	.LVL16:
 458              		.loc 1 749 0
 459 0238 464B     		ldr	r3, .L77+100
 460 023a 0C68     		ldr	r4, [r1]
 461 023c 1868     		ldr	r0, [r3]
 462 023e 484B     		ldr	r3, .L77+112
 463 0240 8442     		cmp	r4, r0
 464 0242 0BD2     		bcs	.L30
 750:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 751:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_ACK;
 465              		.loc 1 751 0
 466 0244 0120     		movs	r0, #1
 467 0246 1860     		str	r0, [r3]
 752:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 753:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Put data into component buffer */
 754:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufPtr[I2C_slWrBufIndex] = (uint8) diffCount;
 468              		.loc 1 754 0
 469 0248 3948     		ldr	r0, .L77+64
 470 024a 0B68     		ldr	r3, [r1]
 471 024c 0068     		ldr	r0, [r0]
 472 024e D2B2     		uxtb	r2, r2
 473              	.LVL17:
 474 0250 C318     		adds	r3, r0, r3
 475 0252 1A70     		strb	r2, [r3]
 755:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slWrBufIndex++;
 476              		.loc 1 755 0
 477 0254 0B68     		ldr	r3, [r1]
 478 0256 0133     		adds	r3, r3, #1
 479 0258 0B60     		str	r3, [r1]
 480 025a 06E0     		b	.L31
 481              	.LVL18:
 482              	.L30:
 756:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 757:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 else /* Overflow: there is no space in write buffer */
 758:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 23


 759:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_I2C_SLAVE_GENERATE_NACK;
 483              		.loc 1 759 0
 484 025c 0222     		movs	r2, #2
 485              	.LVL19:
 760:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 761:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     I2C_slStatus |= (uint8) I2C_I2C_SSTAT_WR_OVFL;
 486              		.loc 1 761 0
 487 025e 4021     		movs	r1, #64
 759:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 488              		.loc 1 759 0
 489 0260 1A60     		str	r2, [r3]
 490              		.loc 1 761 0
 491 0262 284A     		ldr	r2, .L77+20
 492 0264 1378     		ldrb	r3, [r2]
 493 0266 0B43     		orrs	r3, r1
 494 0268 1370     		strb	r3, [r2]
 495              	.L31:
 762:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 763:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 764:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearRxInterruptSource(I2C_INTR_RX_NOT_EMPTY);
 496              		.loc 1 764 0
 497 026a 0422     		movs	r2, #4
 498              	.LVL20:
 499              	.L72:
 500 026c 344B     		ldr	r3, .L77+80
 501 026e 1A60     		str	r2, [r3]
 502              	.L29:
 765:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 766:Generated_Source\PSoC4/I2C_I2C_INT.c ****             else
 767:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 768:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 /* Does nothing */
 769:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 770:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 771:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 772:Generated_Source\PSoC4/I2C_I2C_INT.c ****             /* I2C_INTR_TX_EMPTY:
 773:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The master reads the slave: provide data to read or 0xFF in the case of the end of th
 774:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * The overflow condition must be captured, but not set until the end of transaction.
 775:Generated_Source\PSoC4/I2C_I2C_INT.c ****             * There is a possibility of a false overflow due to TX FIFO utilization.
 776:Generated_Source\PSoC4/I2C_I2C_INT.c ****             */
 777:Generated_Source\PSoC4/I2C_I2C_INT.c ****             if(I2C_CHECK_INTR_TX_MASKED(I2C_INTR_TX_EMPTY))
 503              		.loc 1 777 0
 504 0270 3D4B     		ldr	r3, .L77+120
 505 0272 1B68     		ldr	r3, [r3]
 506 0274 DB06     		lsls	r3, r3, #27
 507 0276 3AD5     		bpl	.L1
 778:Generated_Source\PSoC4/I2C_I2C_INT.c ****             {
 779:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 while(I2C_I2C_FIFO_SIZE != I2C_GET_TX_FIFO_ENTRIES)
 508              		.loc 1 779 0
 509 0278 1F21     		movs	r1, #31
 780:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 781:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Temporary slRdBufIndexTmp is used because the master can NACK the byte and
 782:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * index roll-back is required in this case. The slRdBufIndex is updated at the 
 783:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     * of the read transfer.
 784:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     */
 785:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     if(I2C_slRdBufIndexTmp < I2C_slRdBufSize)
 786:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Data from buffer */
 787:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 24


 788:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = (uint32) I2C_slRdBufPtr[I2C_slRdBufIndexTmp];
 789:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 790:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 791:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     else
 792:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Probably Overflow */
 793:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     {
 794:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_TX_FIFO_WR_REG = I2C_I2C_SLAVE_OVFL_RETURN;
 510              		.loc 1 794 0
 511 027a FF25     		movs	r5, #255
 788:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 512              		.loc 1 788 0
 513 027c 3B4B     		ldr	r3, .L77+124
 779:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 514              		.loc 1 779 0
 515 027e 2448     		ldr	r0, .L77+32
 788:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 516              		.loc 1 788 0
 517 0280 1C68     		ldr	r4, [r3]
 785:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Data from buffer */
 518              		.loc 1 785 0
 519 0282 224A     		ldr	r2, .L77+28
 520              	.L33:
 779:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 {
 521              		.loc 1 779 0
 522 0284 0368     		ldr	r3, [r0]
 523 0286 0B40     		ands	r3, r1
 524 0288 082B     		cmp	r3, #8
 525 028a 18D0     		beq	.L76
 785:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     /* Data from buffer */
 526              		.loc 1 785 0
 527 028c 384B     		ldr	r3, .L77+128
 528 028e 1768     		ldr	r7, [r2]
 529 0290 1B68     		ldr	r3, [r3]
 530 0292 384E     		ldr	r6, .L77+132
 531 0294 9F42     		cmp	r7, r3
 532 0296 08D2     		bcs	.L34
 788:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         I2C_slRdBufIndexTmp++;
 533              		.loc 1 788 0
 534 0298 1368     		ldr	r3, [r2]
 535 029a E318     		adds	r3, r4, r3
 536 029c 1B78     		ldrb	r3, [r3]
 537 029e DBB2     		uxtb	r3, r3
 538 02a0 3360     		str	r3, [r6]
 789:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 539              		.loc 1 789 0
 540 02a2 1368     		ldr	r3, [r2]
 541 02a4 0133     		adds	r3, r3, #1
 542 02a6 1360     		str	r3, [r2]
 543 02a8 ECE7     		b	.L33
 544              	.L34:
 545              		.loc 1 794 0
 546 02aa 3560     		str	r5, [r6]
 795:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 796:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         if(I2C_slOverFlowCount <= I2C_I2C_TX_OVERFLOW_COUNT)
 547              		.loc 1 796 0
 548 02ac 194E     		ldr	r6, .L77+36
 549 02ae 3378     		ldrb	r3, [r6]
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 25


 550 02b0 0A2B     		cmp	r3, #10
 551 02b2 E7D8     		bhi	.L33
 797:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         {
 798:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             /* Get counter in range of overflow. */
 799:Generated_Source\PSoC4/I2C_I2C_INT.c ****                             I2C_slOverFlowCount++;
 552              		.loc 1 799 0
 553 02b4 3378     		ldrb	r3, [r6]
 554 02b6 0133     		adds	r3, r3, #1
 555 02b8 DBB2     		uxtb	r3, r3
 556 02ba 3370     		strb	r3, [r6]
 557 02bc E2E7     		b	.L33
 558              	.L76:
 800:Generated_Source\PSoC4/I2C_I2C_INT.c ****                         }
 801:Generated_Source\PSoC4/I2C_I2C_INT.c ****                     }
 802:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 }
 803:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 804:Generated_Source\PSoC4/I2C_I2C_INT.c ****                 I2C_ClearTxInterruptSource(I2C_INTR_TX_EMPTY);
 559              		.loc 1 804 0
 560 02be 1022     		movs	r2, #16
 561 02c0 2D4B     		ldr	r3, .L77+136
 562 02c2 1A60     		str	r2, [r3]
 563 02c4 13E0     		b	.L1
 564              	.LVL21:
 565              	.L9:
 805:Generated_Source\PSoC4/I2C_I2C_INT.c ****             }
 806:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 807:Generated_Source\PSoC4/I2C_I2C_INT.c ****         }  /* (I2C_I2C_SLAVE) */
 808:Generated_Source\PSoC4/I2C_I2C_INT.c ****         #endif
 809:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 810:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 811:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 812:Generated_Source\PSoC4/I2C_I2C_INT.c ****     /* FSM EXIT:
 813:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Slave:  INTR_SLAVE_I2C_BUS_ERROR, INTR_SLAVE_I2C_ARB_LOST
 814:Generated_Source\PSoC4/I2C_I2C_INT.c ****     * Master: INTR_MASTER_I2C_BUS_ERROR, INTR_MASTER_I2C_ARB_LOST.
 815:Generated_Source\PSoC4/I2C_I2C_INT.c ****     */
 816:Generated_Source\PSoC4/I2C_I2C_INT.c ****     else
 817:Generated_Source\PSoC4/I2C_I2C_INT.c ****     {
 818:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG &= (uint32) ~I2C_CTRL_ENABLED; /* Disable scb IP */
 566              		.loc 1 818 0
 567 02c6 2D49     		ldr	r1, .L77+140
 568 02c8 0A68     		ldr	r2, [r1]
 569 02ca 5200     		lsls	r2, r2, #1
 570 02cc 5208     		lsrs	r2, r2, #1
 571 02ce 0A60     		str	r2, [r1]
 819:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 820:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_state = I2C_I2C_FSM_IDLE;
 572              		.loc 1 820 0
 573 02d0 1870     		strb	r0, [r3]
 821:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 822:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_SLAVE_AUTO_DATA;
 574              		.loc 1 822 0
 575 02d2 154B     		ldr	r3, .L77+56
 576 02d4 194A     		ldr	r2, .L77+76
 577 02d6 1868     		ldr	r0, [r3]
 578 02d8 0240     		ands	r2, r0
 579 02da 1A60     		str	r2, [r3]
 823:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_DISABLE_MASTER_AUTO_DATA;
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 26


 580              		.loc 1 823 0
 581 02dc 1868     		ldr	r0, [r3]
 582 02de 284A     		ldr	r2, .L77+144
 583 02e0 0240     		ands	r2, r0
 584 02e2 1A60     		str	r2, [r3]
 824:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 825:Generated_Source\PSoC4/I2C_I2C_INT.c ****     #if(I2C_CY_SCBIP_V0)
 826:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetRxInterruptMode(I2C_NO_INTR_SOURCES);
 827:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_SetTxInterruptMode(I2C_NO_INTR_SOURCES);
 828:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 829:Generated_Source\PSoC4/I2C_I2C_INT.c ****         /* Clear interrupt sources as they are not automatically cleared after SCB is disabled */
 830:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearTxInterruptSource(I2C_INTR_RX_ALL);
 831:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearRxInterruptSource(I2C_INTR_TX_ALL);
 832:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearSlaveInterruptSource(I2C_INTR_SLAVE_ALL);
 833:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_ClearMasterInterruptSource(I2C_INTR_MASTER_ALL);
 834:Generated_Source\PSoC4/I2C_I2C_INT.c ****     #endif /* (I2C_CY_SCBIP_V0) */
 835:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 836:Generated_Source\PSoC4/I2C_I2C_INT.c ****         I2C_CTRL_REG |= (uint32) I2C_CTRL_ENABLED;  /* Enable scb IP */
 585              		.loc 1 836 0
 586 02e4 8022     		movs	r2, #128
 587 02e6 0B68     		ldr	r3, [r1]
 588 02e8 1206     		lsls	r2, r2, #24
 589 02ea 1343     		orrs	r3, r2
 590 02ec 0B60     		str	r3, [r1]
 591              	.LVL22:
 592              	.L1:
 837:Generated_Source\PSoC4/I2C_I2C_INT.c ****     }
 838:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 839:Generated_Source\PSoC4/I2C_I2C_INT.c **** #ifdef I2C_I2C_ISR_EXIT_CALLBACK
 840:Generated_Source\PSoC4/I2C_I2C_INT.c ****     I2C_I2C_ISR_ExitCallback();
 841:Generated_Source\PSoC4/I2C_I2C_INT.c **** #endif /* I2C_I2C_ISR_EXIT_CALLBACK */
 842:Generated_Source\PSoC4/I2C_I2C_INT.c **** 
 843:Generated_Source\PSoC4/I2C_I2C_INT.c **** }
 593              		.loc 1 843 0
 594              		@ sp needed
 595 02ee F7BD     		pop	{r0, r1, r2, r4, r5, r6, r7, pc}
 596              	.L78:
 597              		.align	2
 598              	.L77:
 599 02f0 00000000 		.word	I2C_customIntrHandler
 600 02f4 8C0E0940 		.word	1074335372
 601 02f8 880E0940 		.word	1074335368
 602 02fc 00000000 		.word	I2C_state
 603 0300 4C0F0940 		.word	1074335564
 604 0304 00000000 		.word	I2C_slStatus
 605 0308 400F0940 		.word	1074335552
 606 030c 00000000 		.word	I2C_slRdBufIndexTmp
 607 0310 08020940 		.word	1074332168
 608 0314 00000000 		.word	I2C_slOverFlowCount
 609 0318 00000000 		.word	I2C_slRdBufIndex
 610 031c 880F0940 		.word	1074335624
 611 0320 04020940 		.word	1074332164
 612 0324 FFFFFEFF 		.word	-65537
 613 0328 60000940 		.word	1074331744
 614 032c 00000000 		.word	I2C_slWrBufIndex
 615 0330 00000000 		.word	I2C_slWrBufPtr
 616 0334 08030940 		.word	1074332424
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 27


 617 0338 40030940 		.word	1074332480
 618 033c FF5FFFFF 		.word	-40961
 619 0340 C00F0940 		.word	1074335680
 620 0344 C80F0940 		.word	1074335688
 621 0348 ED0F0000 		.word	4077
 622 034c 800E0940 		.word	1074335360
 623 0350 64000940 		.word	1074331748
 624 0354 00000000 		.word	I2C_slWrBufSize
 625 0358 FF0F0000 		.word	4095
 626 035c 480F0940 		.word	1074335560
 627 0360 6C000940 		.word	1074331756
 628 0364 CC0F0940 		.word	1074335692
 629 0368 8C0F0940 		.word	1074335628
 630 036c 00000000 		.word	I2C_slRdBufPtr
 631 0370 00000000 		.word	I2C_slRdBufSize
 632 0374 40020940 		.word	1074332224
 633 0378 800F0940 		.word	1074335616
 634 037c 00000940 		.word	1074331648
 635 0380 FFFCFFFF 		.word	-769
 636              		.cfi_endproc
 637              	.LFE1:
 638              		.size	I2C_I2C_ISR, .-I2C_I2C_ISR
 639              		.text
 640              	.Letext0:
 641              		.file 2 "Generated_Source\\PSoC4/cytypes.h"
 642              		.file 3 "Generated_Source\\PSoC4\\I2C_PVT.h"
 643              		.file 4 "Generated_Source\\PSoC4\\I2C_I2C_PVT.h"
 644              		.section	.debug_info,"",%progbits
 645              	.Ldebug_info0:
 646 0000 7F010000 		.4byte	0x17f
 647 0004 0400     		.2byte	0x4
 648 0006 00000000 		.4byte	.Ldebug_abbrev0
 649 000a 04       		.byte	0x4
 650 000b 01       		.uleb128 0x1
 651 000c 3B000000 		.4byte	.LASF31
 652 0010 0C       		.byte	0xc
 653 0011 29020000 		.4byte	.LASF32
 654 0015 56010000 		.4byte	.LASF33
 655 0019 00000000 		.4byte	.Ldebug_ranges0+0
 656 001d 00000000 		.4byte	0
 657 0021 00000000 		.4byte	.Ldebug_line0
 658 0025 02       		.uleb128 0x2
 659 0026 01       		.byte	0x1
 660 0027 06       		.byte	0x6
 661 0028 7E020000 		.4byte	.LASF0
 662 002c 02       		.uleb128 0x2
 663 002d 01       		.byte	0x1
 664 002e 08       		.byte	0x8
 665 002f E0000000 		.4byte	.LASF1
 666 0033 02       		.uleb128 0x2
 667 0034 02       		.byte	0x2
 668 0035 05       		.byte	0x5
 669 0036 AC010000 		.4byte	.LASF2
 670 003a 02       		.uleb128 0x2
 671 003b 02       		.byte	0x2
 672 003c 07       		.byte	0x7
 673 003d 06000000 		.4byte	.LASF3
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 28


 674 0041 02       		.uleb128 0x2
 675 0042 04       		.byte	0x4
 676 0043 05       		.byte	0x5
 677 0044 69020000 		.4byte	.LASF4
 678 0048 02       		.uleb128 0x2
 679 0049 04       		.byte	0x4
 680 004a 07       		.byte	0x7
 681 004b FD000000 		.4byte	.LASF5
 682 004f 02       		.uleb128 0x2
 683 0050 08       		.byte	0x8
 684 0051 05       		.byte	0x5
 685 0052 16020000 		.4byte	.LASF6
 686 0056 02       		.uleb128 0x2
 687 0057 08       		.byte	0x8
 688 0058 07       		.byte	0x7
 689 0059 CA010000 		.4byte	.LASF7
 690 005d 03       		.uleb128 0x3
 691 005e 04       		.byte	0x4
 692 005f 05       		.byte	0x5
 693 0060 696E7400 		.ascii	"int\000"
 694 0064 02       		.uleb128 0x2
 695 0065 04       		.byte	0x4
 696 0066 07       		.byte	0x7
 697 0067 BD010000 		.4byte	.LASF8
 698 006b 04       		.uleb128 0x4
 699 006c 19010000 		.4byte	.LASF9
 700 0070 02       		.byte	0x2
 701 0071 D201     		.2byte	0x1d2
 702 0073 2C000000 		.4byte	0x2c
 703 0077 04       		.uleb128 0x4
 704 0078 B6010000 		.4byte	.LASF10
 705 007c 02       		.byte	0x2
 706 007d D401     		.2byte	0x1d4
 707 007f 48000000 		.4byte	0x48
 708 0083 02       		.uleb128 0x2
 709 0084 04       		.byte	0x4
 710 0085 04       		.byte	0x4
 711 0086 CD000000 		.4byte	.LASF11
 712 008a 02       		.uleb128 0x2
 713 008b 08       		.byte	0x8
 714 008c 04       		.byte	0x4
 715 008d 4F010000 		.4byte	.LASF12
 716 0091 02       		.uleb128 0x2
 717 0092 01       		.byte	0x1
 718 0093 08       		.byte	0x8
 719 0094 24020000 		.4byte	.LASF13
 720 0098 05       		.uleb128 0x5
 721 0099 6B000000 		.4byte	0x6b
 722 009d 04       		.uleb128 0x4
 723 009e 00000000 		.4byte	.LASF14
 724 00a2 02       		.byte	0x2
 725 00a3 7E02     		.2byte	0x27e
 726 00a5 A9000000 		.4byte	0xa9
 727 00a9 05       		.uleb128 0x5
 728 00aa 77000000 		.4byte	0x77
 729 00ae 04       		.uleb128 0x4
 730 00af E1010000 		.4byte	.LASF15
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 29


 731 00b3 02       		.byte	0x2
 732 00b4 8E02     		.2byte	0x28e
 733 00b6 BA000000 		.4byte	0xba
 734 00ba 06       		.uleb128 0x6
 735 00bb 04       		.byte	0x4
 736 00bc C0000000 		.4byte	0xc0
 737 00c0 07       		.uleb128 0x7
 738 00c1 02       		.uleb128 0x2
 739 00c2 08       		.byte	0x8
 740 00c3 04       		.byte	0x4
 741 00c4 72020000 		.4byte	.LASF16
 742 00c8 02       		.uleb128 0x2
 743 00c9 04       		.byte	0x4
 744 00ca 07       		.byte	0x7
 745 00cb 0D020000 		.4byte	.LASF17
 746 00cf 08       		.uleb128 0x8
 747 00d0 43010000 		.4byte	.LASF34
 748 00d4 01       		.byte	0x1
 749 00d5 1F       		.byte	0x1f
 750 00d6 00000000 		.4byte	.LFB1
 751 00da 84030000 		.4byte	.LFE1-.LFB1
 752 00de 01       		.uleb128 0x1
 753 00df 9C       		.byte	0x9c
 754 00e0 03010000 		.4byte	0x103
 755 00e4 09       		.uleb128 0x9
 756 00e5 0F010000 		.4byte	.LASF18
 757 00e9 01       		.byte	0x1
 758 00ea 21       		.byte	0x21
 759 00eb 77000000 		.4byte	0x77
 760 00ef 00000000 		.4byte	.LLST0
 761 00f3 09       		.uleb128 0x9
 762 00f4 19000000 		.4byte	.LASF19
 763 00f8 01       		.byte	0x1
 764 00f9 22       		.byte	0x22
 765 00fa 77000000 		.4byte	0x77
 766 00fe 60000000 		.4byte	.LLST1
 767 0102 00       		.byte	0
 768 0103 0A       		.uleb128 0xa
 769 0104 25000000 		.4byte	.LASF20
 770 0108 03       		.byte	0x3
 771 0109 3B       		.byte	0x3b
 772 010a AE000000 		.4byte	0xae
 773 010e 0A       		.uleb128 0xa
 774 010f 5F020000 		.4byte	.LASF21
 775 0113 04       		.byte	0x4
 776 0114 1E       		.byte	0x1e
 777 0115 98000000 		.4byte	0x98
 778 0119 0A       		.uleb128 0xa
 779 011a D3000000 		.4byte	.LASF22
 780 011e 04       		.byte	0x4
 781 011f 21       		.byte	0x21
 782 0120 98000000 		.4byte	0x98
 783 0124 0A       		.uleb128 0xa
 784 0125 FE010000 		.4byte	.LASF23
 785 0129 04       		.byte	0x4
 786 012a 24       		.byte	0x24
 787 012b 2F010000 		.4byte	0x12f
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 30


 788 012f 06       		.uleb128 0x6
 789 0130 04       		.byte	0x4
 790 0131 98000000 		.4byte	0x98
 791 0135 0A       		.uleb128 0xa
 792 0136 EE010000 		.4byte	.LASF24
 793 013a 04       		.byte	0x4
 794 013b 25       		.byte	0x25
 795 013c A9000000 		.4byte	0xa9
 796 0140 0A       		.uleb128 0xa
 797 0141 9B010000 		.4byte	.LASF25
 798 0145 04       		.byte	0x4
 799 0146 26       		.byte	0x26
 800 0147 A9000000 		.4byte	0xa9
 801 014b 0A       		.uleb128 0xa
 802 014c EE000000 		.4byte	.LASF26
 803 0150 04       		.byte	0x4
 804 0151 29       		.byte	0x29
 805 0152 2F010000 		.4byte	0x12f
 806 0156 0A       		.uleb128 0xa
 807 0157 1F010000 		.4byte	.LASF27
 808 015b 04       		.byte	0x4
 809 015c 2A       		.byte	0x2a
 810 015d A9000000 		.4byte	0xa9
 811 0161 0A       		.uleb128 0xa
 812 0162 4E020000 		.4byte	.LASF28
 813 0166 04       		.byte	0x4
 814 0167 2B       		.byte	0x2b
 815 0168 A9000000 		.4byte	0xa9
 816 016c 0A       		.uleb128 0xa
 817 016d 8A020000 		.4byte	.LASF29
 818 0171 04       		.byte	0x4
 819 0172 2C       		.byte	0x2c
 820 0173 A9000000 		.4byte	0xa9
 821 0177 0A       		.uleb128 0xa
 822 0178 2F010000 		.4byte	.LASF30
 823 017c 04       		.byte	0x4
 824 017d 2D       		.byte	0x2d
 825 017e 98000000 		.4byte	0x98
 826 0182 00       		.byte	0
 827              		.section	.debug_abbrev,"",%progbits
 828              	.Ldebug_abbrev0:
 829 0000 01       		.uleb128 0x1
 830 0001 11       		.uleb128 0x11
 831 0002 01       		.byte	0x1
 832 0003 25       		.uleb128 0x25
 833 0004 0E       		.uleb128 0xe
 834 0005 13       		.uleb128 0x13
 835 0006 0B       		.uleb128 0xb
 836 0007 03       		.uleb128 0x3
 837 0008 0E       		.uleb128 0xe
 838 0009 1B       		.uleb128 0x1b
 839 000a 0E       		.uleb128 0xe
 840 000b 55       		.uleb128 0x55
 841 000c 17       		.uleb128 0x17
 842 000d 11       		.uleb128 0x11
 843 000e 01       		.uleb128 0x1
 844 000f 10       		.uleb128 0x10
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 31


 845 0010 17       		.uleb128 0x17
 846 0011 00       		.byte	0
 847 0012 00       		.byte	0
 848 0013 02       		.uleb128 0x2
 849 0014 24       		.uleb128 0x24
 850 0015 00       		.byte	0
 851 0016 0B       		.uleb128 0xb
 852 0017 0B       		.uleb128 0xb
 853 0018 3E       		.uleb128 0x3e
 854 0019 0B       		.uleb128 0xb
 855 001a 03       		.uleb128 0x3
 856 001b 0E       		.uleb128 0xe
 857 001c 00       		.byte	0
 858 001d 00       		.byte	0
 859 001e 03       		.uleb128 0x3
 860 001f 24       		.uleb128 0x24
 861 0020 00       		.byte	0
 862 0021 0B       		.uleb128 0xb
 863 0022 0B       		.uleb128 0xb
 864 0023 3E       		.uleb128 0x3e
 865 0024 0B       		.uleb128 0xb
 866 0025 03       		.uleb128 0x3
 867 0026 08       		.uleb128 0x8
 868 0027 00       		.byte	0
 869 0028 00       		.byte	0
 870 0029 04       		.uleb128 0x4
 871 002a 16       		.uleb128 0x16
 872 002b 00       		.byte	0
 873 002c 03       		.uleb128 0x3
 874 002d 0E       		.uleb128 0xe
 875 002e 3A       		.uleb128 0x3a
 876 002f 0B       		.uleb128 0xb
 877 0030 3B       		.uleb128 0x3b
 878 0031 05       		.uleb128 0x5
 879 0032 49       		.uleb128 0x49
 880 0033 13       		.uleb128 0x13
 881 0034 00       		.byte	0
 882 0035 00       		.byte	0
 883 0036 05       		.uleb128 0x5
 884 0037 35       		.uleb128 0x35
 885 0038 00       		.byte	0
 886 0039 49       		.uleb128 0x49
 887 003a 13       		.uleb128 0x13
 888 003b 00       		.byte	0
 889 003c 00       		.byte	0
 890 003d 06       		.uleb128 0x6
 891 003e 0F       		.uleb128 0xf
 892 003f 00       		.byte	0
 893 0040 0B       		.uleb128 0xb
 894 0041 0B       		.uleb128 0xb
 895 0042 49       		.uleb128 0x49
 896 0043 13       		.uleb128 0x13
 897 0044 00       		.byte	0
 898 0045 00       		.byte	0
 899 0046 07       		.uleb128 0x7
 900 0047 15       		.uleb128 0x15
 901 0048 00       		.byte	0
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 32


 902 0049 27       		.uleb128 0x27
 903 004a 19       		.uleb128 0x19
 904 004b 00       		.byte	0
 905 004c 00       		.byte	0
 906 004d 08       		.uleb128 0x8
 907 004e 2E       		.uleb128 0x2e
 908 004f 01       		.byte	0x1
 909 0050 3F       		.uleb128 0x3f
 910 0051 19       		.uleb128 0x19
 911 0052 03       		.uleb128 0x3
 912 0053 0E       		.uleb128 0xe
 913 0054 3A       		.uleb128 0x3a
 914 0055 0B       		.uleb128 0xb
 915 0056 3B       		.uleb128 0x3b
 916 0057 0B       		.uleb128 0xb
 917 0058 27       		.uleb128 0x27
 918 0059 19       		.uleb128 0x19
 919 005a 11       		.uleb128 0x11
 920 005b 01       		.uleb128 0x1
 921 005c 12       		.uleb128 0x12
 922 005d 06       		.uleb128 0x6
 923 005e 40       		.uleb128 0x40
 924 005f 18       		.uleb128 0x18
 925 0060 9642     		.uleb128 0x2116
 926 0062 19       		.uleb128 0x19
 927 0063 01       		.uleb128 0x1
 928 0064 13       		.uleb128 0x13
 929 0065 00       		.byte	0
 930 0066 00       		.byte	0
 931 0067 09       		.uleb128 0x9
 932 0068 34       		.uleb128 0x34
 933 0069 00       		.byte	0
 934 006a 03       		.uleb128 0x3
 935 006b 0E       		.uleb128 0xe
 936 006c 3A       		.uleb128 0x3a
 937 006d 0B       		.uleb128 0xb
 938 006e 3B       		.uleb128 0x3b
 939 006f 0B       		.uleb128 0xb
 940 0070 49       		.uleb128 0x49
 941 0071 13       		.uleb128 0x13
 942 0072 02       		.uleb128 0x2
 943 0073 17       		.uleb128 0x17
 944 0074 00       		.byte	0
 945 0075 00       		.byte	0
 946 0076 0A       		.uleb128 0xa
 947 0077 34       		.uleb128 0x34
 948 0078 00       		.byte	0
 949 0079 03       		.uleb128 0x3
 950 007a 0E       		.uleb128 0xe
 951 007b 3A       		.uleb128 0x3a
 952 007c 0B       		.uleb128 0xb
 953 007d 3B       		.uleb128 0x3b
 954 007e 0B       		.uleb128 0xb
 955 007f 49       		.uleb128 0x49
 956 0080 13       		.uleb128 0x13
 957 0081 3F       		.uleb128 0x3f
 958 0082 19       		.uleb128 0x19
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 33


 959 0083 3C       		.uleb128 0x3c
 960 0084 19       		.uleb128 0x19
 961 0085 00       		.byte	0
 962 0086 00       		.byte	0
 963 0087 00       		.byte	0
 964              		.section	.debug_loc,"",%progbits
 965              	.Ldebug_loc0:
 966              	.LLST0:
 967 0000 8E000000 		.4byte	.LVL2
 968 0004 98000000 		.4byte	.LVL3
 969 0008 0100     		.2byte	0x1
 970 000a 52       		.byte	0x52
 971 000b 9E000000 		.4byte	.LVL4
 972 000f A4000000 		.4byte	.LVL5
 973 0013 0100     		.2byte	0x1
 974 0015 52       		.byte	0x52
 975 0016 8C010000 		.4byte	.LVL6
 976 001a 9C010000 		.4byte	.LVL7
 977 001e 0100     		.2byte	0x1
 978 0020 52       		.byte	0x52
 979 0021 A4010000 		.4byte	.LVL8
 980 0025 A8010000 		.4byte	.LVL9
 981 0029 0100     		.2byte	0x1
 982 002b 52       		.byte	0x52
 983 002c EC010000 		.4byte	.LVL10
 984 0030 F6010000 		.4byte	.LVL11
 985 0034 0100     		.2byte	0x1
 986 0036 53       		.byte	0x53
 987 0037 FA010000 		.4byte	.LVL12
 988 003b 2C020000 		.4byte	.LVL15
 989 003f 0100     		.2byte	0x1
 990 0041 53       		.byte	0x53
 991 0042 38020000 		.4byte	.LVL16
 992 0046 50020000 		.4byte	.LVL17
 993 004a 0100     		.2byte	0x1
 994 004c 52       		.byte	0x52
 995 004d 5C020000 		.4byte	.LVL18
 996 0051 5E020000 		.4byte	.LVL19
 997 0055 0100     		.2byte	0x1
 998 0057 52       		.byte	0x52
 999 0058 00000000 		.4byte	0
 1000 005c 00000000 		.4byte	0
 1001              	.LLST1:
 1002 0060 00000000 		.4byte	.LVL0
 1003 0064 FA010000 		.4byte	.LVL12
 1004 0068 0200     		.2byte	0x2
 1005 006a 30       		.byte	0x30
 1006 006b 9F       		.byte	0x9f
 1007 006c FA010000 		.4byte	.LVL12
 1008 0070 1A020000 		.4byte	.LVL14
 1009 0074 0100     		.2byte	0x1
 1010 0076 50       		.byte	0x50
 1011 0077 2C020000 		.4byte	.LVL15
 1012 007b 6C020000 		.4byte	.LVL20
 1013 007f 0200     		.2byte	0x2
 1014 0081 30       		.byte	0x30
 1015 0082 9F       		.byte	0x9f
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 34


 1016 0083 C6020000 		.4byte	.LVL21
 1017 0087 EE020000 		.4byte	.LVL22
 1018 008b 0200     		.2byte	0x2
 1019 008d 30       		.byte	0x30
 1020 008e 9F       		.byte	0x9f
 1021 008f 00000000 		.4byte	0
 1022 0093 00000000 		.4byte	0
 1023              		.section	.debug_aranges,"",%progbits
 1024 0000 1C000000 		.4byte	0x1c
 1025 0004 0200     		.2byte	0x2
 1026 0006 00000000 		.4byte	.Ldebug_info0
 1027 000a 04       		.byte	0x4
 1028 000b 00       		.byte	0
 1029 000c 0000     		.2byte	0
 1030 000e 0000     		.2byte	0
 1031 0010 00000000 		.4byte	.LFB1
 1032 0014 84030000 		.4byte	.LFE1-.LFB1
 1033 0018 00000000 		.4byte	0
 1034 001c 00000000 		.4byte	0
 1035              		.section	.debug_ranges,"",%progbits
 1036              	.Ldebug_ranges0:
 1037 0000 00000000 		.4byte	.LFB1
 1038 0004 84030000 		.4byte	.LFE1
 1039 0008 00000000 		.4byte	0
 1040 000c 00000000 		.4byte	0
 1041              		.section	.debug_line,"",%progbits
 1042              	.Ldebug_line0:
 1043 0000 41010000 		.section	.debug_str,"MS",%progbits,1
 1043      02006600 
 1043      00000201 
 1043      FB0E0D00 
 1043      01010101 
 1044              	.LASF14:
 1045 0000 72656733 		.ascii	"reg32\000"
 1045      3200
 1046              	.LASF3:
 1047 0006 73686F72 		.ascii	"short unsigned int\000"
 1047      7420756E 
 1047      7369676E 
 1047      65642069 
 1047      6E7400
 1048              	.LASF19:
 1049 0019 656E6454 		.ascii	"endTransfer\000"
 1049      72616E73 
 1049      66657200 
 1050              	.LASF20:
 1051 0025 4932435F 		.ascii	"I2C_customIntrHandler\000"
 1051      63757374 
 1051      6F6D496E 
 1051      74724861 
 1051      6E646C65 
 1052              	.LASF31:
 1053 003b 474E5520 		.ascii	"GNU C11 5.4.1 20160609 (release) [ARM/embedded-5-br"
 1053      43313120 
 1053      352E342E 
 1053      31203230 
 1053      31363036 
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 35


 1054 006e 616E6368 		.ascii	"anch revision 237715] -mcpu=cortex-m0plus -mthumb -"
 1054      20726576 
 1054      6973696F 
 1054      6E203233 
 1054      37373135 
 1055 00a1 67202D4F 		.ascii	"g -Os -ffunction-sections -ffat-lto-objects\000"
 1055      73202D66 
 1055      66756E63 
 1055      74696F6E 
 1055      2D736563 
 1056              	.LASF11:
 1057 00cd 666C6F61 		.ascii	"float\000"
 1057      7400
 1058              	.LASF22:
 1059 00d3 4932435F 		.ascii	"I2C_slStatus\000"
 1059      736C5374 
 1059      61747573 
 1059      00
 1060              	.LASF1:
 1061 00e0 756E7369 		.ascii	"unsigned char\000"
 1061      676E6564 
 1061      20636861 
 1061      7200
 1062              	.LASF26:
 1063 00ee 4932435F 		.ascii	"I2C_slRdBufPtr\000"
 1063      736C5264 
 1063      42756650 
 1063      747200
 1064              	.LASF5:
 1065 00fd 6C6F6E67 		.ascii	"long unsigned int\000"
 1065      20756E73 
 1065      69676E65 
 1065      6420696E 
 1065      7400
 1066              	.LASF18:
 1067 010f 64696666 		.ascii	"diffCount\000"
 1067      436F756E 
 1067      7400
 1068              	.LASF9:
 1069 0119 75696E74 		.ascii	"uint8\000"
 1069      3800
 1070              	.LASF27:
 1071 011f 4932435F 		.ascii	"I2C_slRdBufSize\000"
 1071      736C5264 
 1071      42756653 
 1071      697A6500 
 1072              	.LASF30:
 1073 012f 4932435F 		.ascii	"I2C_slOverFlowCount\000"
 1073      736C4F76 
 1073      6572466C 
 1073      6F77436F 
 1073      756E7400 
 1074              	.LASF34:
 1075 0143 4932435F 		.ascii	"I2C_I2C_ISR\000"
 1075      4932435F 
 1075      49535200 
 1076              	.LASF12:
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 36


 1077 014f 646F7562 		.ascii	"double\000"
 1077      6C6500
 1078              	.LASF33:
 1079 0156 433A5C55 		.ascii	"C:\\Users\\Stephen\\Documents\\Firmware\\PSoC\\Boot"
 1079      73657273 
 1079      5C537465 
 1079      7068656E 
 1079      5C446F63 
 1080 0183 6C6F6164 		.ascii	"loader\\Bootloader.cydsn\000"
 1080      65725C42 
 1080      6F6F746C 
 1080      6F616465 
 1080      722E6379 
 1081              	.LASF25:
 1082 019b 4932435F 		.ascii	"I2C_slWrBufIndex\000"
 1082      736C5772 
 1082      42756649 
 1082      6E646578 
 1082      00
 1083              	.LASF2:
 1084 01ac 73686F72 		.ascii	"short int\000"
 1084      7420696E 
 1084      7400
 1085              	.LASF10:
 1086 01b6 75696E74 		.ascii	"uint32\000"
 1086      333200
 1087              	.LASF8:
 1088 01bd 756E7369 		.ascii	"unsigned int\000"
 1088      676E6564 
 1088      20696E74 
 1088      00
 1089              	.LASF7:
 1090 01ca 6C6F6E67 		.ascii	"long long unsigned int\000"
 1090      206C6F6E 
 1090      6720756E 
 1090      7369676E 
 1090      65642069 
 1091              	.LASF15:
 1092 01e1 63796973 		.ascii	"cyisraddress\000"
 1092      72616464 
 1092      72657373 
 1092      00
 1093              	.LASF24:
 1094 01ee 4932435F 		.ascii	"I2C_slWrBufSize\000"
 1094      736C5772 
 1094      42756653 
 1094      697A6500 
 1095              	.LASF23:
 1096 01fe 4932435F 		.ascii	"I2C_slWrBufPtr\000"
 1096      736C5772 
 1096      42756650 
 1096      747200
 1097              	.LASF17:
 1098 020d 73697A65 		.ascii	"sizetype\000"
 1098      74797065 
 1098      00
 1099              	.LASF6:
ARM GAS  C:\Users\Stephen\AppData\Local\Temp\ccRQlgJm.s 			page 37


 1100 0216 6C6F6E67 		.ascii	"long long int\000"
 1100      206C6F6E 
 1100      6720696E 
 1100      7400
 1101              	.LASF13:
 1102 0224 63686172 		.ascii	"char\000"
 1102      00
 1103              	.LASF32:
 1104 0229 47656E65 		.ascii	"Generated_Source\\PSoC4\\I2C_I2C_INT.c\000"
 1104      72617465 
 1104      645F536F 
 1104      75726365 
 1104      5C50536F 
 1105              	.LASF28:
 1106 024e 4932435F 		.ascii	"I2C_slRdBufIndex\000"
 1106      736C5264 
 1106      42756649 
 1106      6E646578 
 1106      00
 1107              	.LASF21:
 1108 025f 4932435F 		.ascii	"I2C_state\000"
 1108      73746174 
 1108      6500
 1109              	.LASF4:
 1110 0269 6C6F6E67 		.ascii	"long int\000"
 1110      20696E74 
 1110      00
 1111              	.LASF16:
 1112 0272 6C6F6E67 		.ascii	"long double\000"
 1112      20646F75 
 1112      626C6500 
 1113              	.LASF0:
 1114 027e 7369676E 		.ascii	"signed char\000"
 1114      65642063 
 1114      68617200 
 1115              	.LASF29:
 1116 028a 4932435F 		.ascii	"I2C_slRdBufIndexTmp\000"
 1116      736C5264 
 1116      42756649 
 1116      6E646578 
 1116      546D7000 
 1117              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 5.4.1 20160609 (release) [ARM/embedded-5-bran
